昨天学习ext4的过程中遇到一个问题，为什么第一次刷盘，调用`mb_find_extent`，对于第521个块和第522个块的返回结果完全不同呢？对于入参是521会返回0，对于入参是522会返回1。非常不理解，按理说它们是挨着的，应该没有特别大的不同才是。

首先简单介绍下`mb_find_extent`这个函数，这个函数接收一个block id为参数，在文件系统内找到从这个block开始的连续的n个块的order，order和n的关系是：n = 2^order。返回0就是说，从第521个块开始，只能找到连续的1个块。返回1，即从第522个块开始，可以找到连续的2个块。

下面是分析过程及结论：

1. 第521个块返回0，是因为第520个块被占用了，第521个块没被占用，所以无法组成buddy，只能返回0

2. 第522个块返回1，是因为第522和第523个块都没被占用，所以可以返回1。

3. 上述两点都可以用block_bitmap和buddy系统的二进制中看到

   1. block_bitmap:

      ![image-20220428000636096](https://github.com/sjc2870/sjc2870.github.io/blob/main/images/block-bitmap.png?raw=true)

      每行8个字节，64个bit，红框所在字节的首地址是`0xffff88800336c041`，与bitmap首地址`0xffff88800336c000`相差0x41个字节，也就是65个字节，也就是519个bit，那我们可以看到明明是第519+8=527个block的bitmap为1，和上面说的520不一致啊。

      造成不一致的原因是字节序。这里有个问题需要注意，我们常规看的字节序是大端字节序，这样看比较符合人类的视角，但在ext4或者在kernel中，都是小端字节序，顺序正好是相反的。所以我们要把我们的大端字节序转换成小端字节序，那么这里也就是`1000 0000`，也就是第519+1=520个block是被占用的，后面的第522 523 524个block是没有被占用的

   2. buddy:

      首先需要明确的一点是，在Buddy系统中，连续的n个块中，只要有任意一个块被占用，那么整个连续的n个块就会被标记为占用。

      ![image-20220428001922583](https://github.com/sjc2870/sjc2870.github.io/blob/main/images/block-buddy.png?raw=true)

      注意，这里的每个bit都是代表了连续的两个块，而不是仅仅代表一个块，那么第521个块所属的bit是(521 >> 1) = 260个bit，第522个块所属的bit是(522 >> 1) = 261个bit。

      如图所示，红框所在字节地址为`0xffff88800336b020`，距离buddy首地址`0xffff88800336b000`相差`0x20`个字节，也就是2*16=32个字节，即32 * 8=256个bit。

      再次注意，起始bit从0开始编号，那么红框所在地址的首个bit其实是第256个bit

      由大端转小端后，这里的数据其实是`1111 1011`，也就是说，第256+4=260个bit的值是1代表占用，第261个bit的值是0代表空闲。

   

   究其根本原因

   1. 是在order=1的场景下，第521个块只能和第520个块组成buddy，而无法和第522个块组成buddy，而第522个块只能和第523个块组成buddy，而无法和第521个块组buddy。
   2. 在Buddy系统中，连续的n个块中，只要有任意一个块被占用，那么整个连续的n个块就会被标记为占用。